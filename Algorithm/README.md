# 学习数据结构和算法

来源：https://www.bilibili.com/video/BV13g41157hK/?spm_id_from=333.999.0.0&vd_source=d6bcbd2fac9e9b84fc22095c62ddbe80
github：https://github.com/algorithmzuo

## Linux环境配置java开发环境

### 安装
- sudo apt install openjdk-11-jdk(安装OpenJDK 11软件包)
- java --version(检查是否安装成功)
- sudo update-alternatives --config java(修改默认版本)

### 配置环境变量
- 找到java的安装位置：sudo update-alternatives --config java
  - /usr/lib/jvm/java-11-openjdk-amd64/bin/java
- 找到安装路径后，打开/etc/environment文件：sudo vim /etc/enviroment
- 在该文件末尾加上：JAVA_HOME = "path", path为刚才查找到的路径
  - 例如：JAVA_HOME = "/usr/lib/jvm/java-11-openjdk-amd64"
  - 注意：如果有多个路径，选择一个即可，并且不需要/bin/java
- 使该文件生效：source /etc/environment

### 卸载java
- sudo apt remove openjdk-11-jdk

### 运行java文件
- 创建java文件，例如：demo1.java
- 编写代码
- 在bash中输入命令：javac demo1.java，该命令将会产生一个.class文件
- 运行代码：java demo1


## 数据结构与算法
### 选择排序
描述：从数组中选择一个最小值放在数组的第一个位置，然后再从剩下的元素中选择最小值放在第二个位置，以此类推，直到最后一个元素
- 循环第一次寻找第一个元素到最后一个元素的最小值，放在第一个元素的位置
- 循环第二次寻找第二个元素到最后一个元素的最小值，放在第二个元素的位置
- 以此内推，直至排序完成


### 冒泡排序
描述：从第一个元素开始，相邻两个元素相互比较，较大的元素往右移动（两两交换），直到倒数第二个元素
- 循环一次将选出一个最大值放在数组末尾
- 第一次循环从第一个元素到倒数第二个元素
- 第二次循环从第一个元素到倒数第三个元素
- ...


### 异或
描述：在一个整形数组中，已知
1. 只有一种数出现了奇数次，其他的所有数都出现了偶数次，怎么找到出现了奇数次的数？
2. 有两种数出现了奇数次，其他的所有数都出现了偶数次，怎么找到这两种数？
要求：时间复杂度O(n), 空间复杂度O(1)

### 插入排序
描述：从第一个元素开始，从该元素往前查找，遇到比自己大的就交换（相邻交换，每次查找一直到第一个元素才结束），否则就开始下一个
- 部分有序-->整体有序


### 二分法
1. 在一个有序数组中，找某个数是否存在
   1. 遍历：时间复杂度O(n)
   2. 二分法：时间复杂度O(nlog(n))
2. 在一个有序数组中，找>=某个数最左侧的位置
3. 局部最小值问题 
   描述：在一个无序数组中，任何两个相邻数一定不相等。
   $a_0 < a_1, a_{n-1} < a_{n-2}, a_{i-1} < a_i < a_{i + 1}$三种情况均为局部最小值，求一个即可，时间复杂度小于O(n)



### 对数器
来源：视频p3，时间：1：59：00
- 构造对数器的步骤：
  - 随机数数组的产生，数组长度随机，数组中的元素随机
    - random函数产生随机的，规定数组的长度的最大值、最小值和测试次数
    - 使用random产生数组的元素
  - 比较不同的算法
    - 构造复制数组的函数
  - 得出结果


### 用递归方法找一个数组中的最大值
- master公式的使用：
  $T(N) = a * T(\frac{N}{b}) + O(N^d)$
  - T(N)指母问题的数据量，规模是N
  - 子问题的规模是N/b的规模，a是子问题被调用的次数
  - 最后一项表示除了调用之外的时间复杂度

- arr[L..R]上返回z最大值 
  - 求中点的索引：mid = L + ((R - L) >> 1)
  - 注意，不要使用：mid = (L + R) / 2，因为如果数组很长，(L + R)可能会溢出，导致计算出的mid不正确
  - $log_b^a < d ---> O(N^d)$
  - $log_b^a > d ---> O(N^{log_b^a})$
  - $log_b^a = d ---> O(N^d * log^N)$


### 归并排序（重要）
- 描述：先让左侧部分排好序，再让右侧部分排好序，最后再合并怕排序


### 快排
- 问题一：
  给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度为O(N)

- 问题二：
  给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度为O(N)

  